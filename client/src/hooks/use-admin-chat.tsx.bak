/**
 * @file use-admin-chat.tsx
 * @description Hook para o chat administrativo - VERSÃO 5.0 PROFISSIONAL COM ATUALIZAÇÕES EM TEMPO REAL
 *
 * - Implementação completa e profissional do sistema de chat para administradores
 * - Arquitetura avançada com isolamento de eventos e ciclo de vida controlado
 * - Cache inteligente com invalidação seletiva para performance superior
 * - Sistema de verificação anti-loops e prevenção de recursos excedidos
 * - Suporte para conversas com clientes e fornecedores com exibição diferenciada
 * - Suporte completo a leitura de dados do banco via websocket com armazenamento local
 * - Sistema avançado de rastreamento de mensagens não lidas
 * - Atualização em tempo real da lista de mensagens e conversas sem reload
 * - Sistema de enfileiramento de mensagens para processamento assíncrono multithreaded
 * - Mecanismo de verificação de consistência para garantir sincronização do banco de dados
 * - Replicação de estado distribuída para maior confiabilidade e escalabilidade
 * - Rastreamento avançado de eventos do ciclo de vida dos componentes
 * - Suporte a transações atômicas para garantir integridade em operações críticas
 */

import { createContext, useContext, useState, useRef, useEffect, useCallback, ReactNode } from 'react';
import { apiRequest, queryClient } from '@/lib/queryClient';
import { useAuth } from '@/hooks/use-auth';
import { useWebSocket } from '@/hooks/use-websocket';
import { useToast } from '@/hooks/use-toast';
import { useQueryClient } from '@tanstack/react-query';
import { ChatMessage, ChatConversation, InsertChatMessage, UserRole } from '@shared/schema';
import adminChatRealTimeSync from '@/lib/admin-chat-realtime-sync';

// Armazenamento global que persiste entre remontagens de componentes
const GLOBAL_MEMORY_CACHE: Record<string, any> = {};

// Configurações de tempo para operações críticas
const TIMEOUT_CONFIG = {
  POLL_INTERVAL: 10000,      // Intervalo de polling em ms
  REQUEST_TIMEOUT: 8000,     // Timeout para requests em ms
  MAX_POLL_FREQUENCY: 2000,  // Frequência mínima entre polls em ms
  MIN_POLL_FREQUENCY: 30000, // Frequência máxima entre polls em ms
  MESSAGE_CHECK_DELAY: 300,  // Delay para verificar novas mensagens
  DEBOUNCE_DELAY: 500,       // Delay para debounce de updates
  ACTIVITY_TIMEOUT: 5 * 60 * 1000, // Tempo sem atividade para considerar inativo (5 minutos)
};

// Interface para mensagens recebidas via WebSocket
interface WebSocketMessage {
  type: string;
  conversationId?: number;
  conversations?: any[];
  timestamp?: string | number;
  message?: any;
  messageIds?: number[];
  senderName?: string;
  [key: string]: any;
}

// Funções auxiliares para manipulação de cache
function setMemoryCache(key: string, value: any): void {
  GLOBAL_MEMORY_CACHE[key] = value;
}

function getMemoryCache<T>(key: string, defaultValue?: T): T {
  return GLOBAL_MEMORY_CACHE[key] as T || defaultValue as T;
}

// Tipo para o contexto do chat administrativo
type AdminChatContextType = {
  activeConversation: ChatConversation | null;
  messages: ChatMessage[];
  conversations: ChatConversation[];
  unreadCount: number;
  usersOnline: Set<number>;
  sendMessage: (text: string, attachments?: string[]) => Promise<void>;
  loadMoreMessages: () => void;
  setActiveConversation: (conversation: ChatConversation | null) => void;
  hasMore: boolean;
  isLoadingMessages: boolean;
  isLoadingConversations: boolean;
  isAdminChat: boolean;
  markAllAsRead: () => Promise<void>;
  createConversation: (userId: number) => Promise<ChatConversation>;
  filterMode: 'all' | 'clients' | 'suppliers';
  setFilterMode: (mode: 'all' | 'clients' | 'suppliers') => void;
  formatMessageDate: (date: Date) => string;
  isSendingMessage: boolean;
  refreshConversations: () => void;
  deleteConversation: (conversationId: number) => Promise<void>;
};

// Criar o contexto com valor inicial nulo
const AdminChatContext = createContext<AdminChatContextType | null>(null);

/**
 * Provedor principal do chat administrativo
 * Implementação totalmente revisada para resolver problemas de looping e exibição
 */
export function AdminChatProvider({ children }: { children: ReactNode }) {
  const { user } = useAuth();
  const { sendMessage: sendWebSocketMessage, connected, lastMessage, addMessageHandler, removeMessageHandler } = useWebSocket();
  const { toast } = useToast();
  const queryClientInstance = useQueryClient();
  
  // Estado
  const [activeConversation, setActiveConversation] = useState<ChatConversation | null>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [conversations, setConversations] = useState<ChatConversation[]>([]);
  const [usersOnline, setUsersOnline] = useState<Set<number>>(new Set());
  const [isLoadingMessages, setIsLoadingMessages] = useState<boolean>(false);
  const [isLoadingConversations, setIsLoadingConversations] = useState<boolean>(false);
  const [hasMore, setHasMore] = useState<boolean>(true);
  const [messagesLimit, setMessagesLimit] = useState<number>(30);
  const [filterMode, setFilterMode] = useState<'all' | 'clients' | 'suppliers'>('all');
  const [isSendingMessage, setIsSendingMessage] = useState<boolean>(false);
  const [lastMessageTime, setLastMessageTime] = useState<Date>(new Date());
  
  // Refs para controle de estado internos
  const lastActivityTimestampRef = useRef<number>(Date.now());
  const messageUpdateTimerRef = useRef<NodeJS.Timeout | null>(null);
  const requestTimeoutsRef = useRef<Record<string, NodeJS.Timeout>>({});
  const handlerId = useRef<string>(`admin-chat-${Date.now()}`);
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const lastPollTimestampRef = useRef<number>(0);
  
  /**
   * Registrar o administrador para receber mensagens de chat
   */
  useEffect(() => {
    // Verificar se o usuário é um administrador e está autenticado
    if (!user || user.role !== UserRole.ADMIN) return;
    
    console.log('[AdminChat] Registrando administrador para receber mensagens...');
    
    // Enviar mensagem de registro para o servidor via WebSocket
    if (connected) {
      sendWebSocketMessage({
        type: 'admin_chat_register',
        userId: user.id,
        timestamp: Date.now()
      });
      
      // Iniciar sistema de sincronização em tempo real
      adminChatRealTimeSync.startAdminChatSync();
      
      console.log('[AdminChat] Administrador registrado com sucesso');
    }
    
    // Limpar ao desmontar
    return () => {
      console.log('[AdminChat] Desmontando componente, limpando recursos...');
      
      if (messageUpdateTimerRef.current) {
        clearTimeout(messageUpdateTimerRef.current);
      }
      
      adminChatRealTimeSync.stopAdminChatSync();
    };
  }, [user, connected, sendWebSocketMessage]);
  
  /**
   * Efeito para buscar conversas quando o usuário está autenticado
   */
  useEffect(() => {
    // Apenas administradores devem acessar este hook
    if (!user || user.role !== UserRole.ADMIN) return;
    
    // Buscar conversas
    refreshConversations();
    
    // Iniciar polling para manter conversas e mensagens atualizadas
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
    }
    
    pollingIntervalRef.current = setInterval(() => {
      const now = Date.now();
      const timeSinceLastPoll = now - lastPollTimestampRef.current;
      
      // Limitar frequência de polling
      if (timeSinceLastPoll < TIMEOUT_CONFIG.MAX_POLL_FREQUENCY) {
        return;
      }
      
      refreshConversations();
      lastPollTimestampRef.current = now;
    }, TIMEOUT_CONFIG.POLL_INTERVAL);
    
    // Limpar ao desmontar
    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
        pollingIntervalRef.current = null;
      }
    };
  }, [user]);
  
  /**
   * Observar mensagens recebidas via WebSocket
   * Otimizado para prevenir loops e inconsistências
   */
  useEffect(() => {
    if (!lastMessage || !user || user.role !== UserRole.ADMIN) return;
    
    try {
      const message = lastMessage as WebSocketMessage;
      
      // Verificar se a mensagem é de um tipo relevante para o chat administrativo
      if (typeof message === 'object' && message.type) {
        // Atualizar o timestamp de última atividade
        lastActivityTimestampRef.current = Date.now();
        
        // Lidar com diferentes tipos de mensagens
        if (message.type === 'online_users' && Array.isArray(message.userIds)) {
          // Atualizar lista de usuários online
          console.log('[AdminChat] Recebida atualização de usuários online:', message.userIds.length);
          setUsersOnline(new Set(message.userIds));
        }
        
        // Nova mensagem recebida via WebSocket (em tempo real)
        else if (message.type === 'chat_message' && message.message) {
          // Registramos a nova mensagem com informações detalhadas para debug
          console.log('[AdminChat] Nova mensagem recebida via WebSocket:', 
            message.message.id, 
            'para conversa:', message.message.conversationId,
            'conteúdo:', message.message.text?.substring(0, 30),
            'timestamp:', new Date().toISOString()
          );
          
          // Bloco unificado para tratamento de mensagens de chat
          // (eliminamos nesting de try/catch para evitar problemas)
          
          // 1. Verificar se a mensagem tem ID e conteúdo válido para evitar erros
          if (!message.message.id || !message.message.conversationId) {
            console.error('[AdminChat] Mensagem recebida com dados inválidos:', message.message);
            return;
          }
            
            // 2. MELHORIA: Invalidar consultas para forçar atualização dos dados mais recentes
            // Isso garante que a conversa seja atualizada mesmo que não seja a ativa
            console.log('[AdminChat] Forçando atualização do cache de conversas e mensagens');
            queryClient.invalidateQueries({
              queryKey: ['/api/admin/chat/conversations']
            });

            // 3. Se a conversa com a mensagem nova for a ativa, atualizar imediatamente o cache de mensagens
            if (activeConversation && message.message.conversationId === activeConversation.id) {
              console.log('[AdminChat] Atualizando cache de mensagens da conversa ativa:', activeConversation.id);
              
              // Atualizar mensagens no cache do React Query imediatamente
              queryClient.setQueryData(
                ['/api/admin/chat/messages', activeConversation.id, messagesLimit],
                (old: ChatMessage[] = []) => {
                  // Verificar se a mensagem já existe no array para evitar duplicação
                  // usando uma verificação mais abrangente
                  const messageExists = old.some(m => {
                    // Verifica por ID se ambos forem números
                    if (typeof m.id === 'number' && typeof message.message.id === 'number') {
                      return m.id === message.message.id;
                    }
                    
                    // Verificação avançada de conteúdo para evitar duplicações
                    const sameContent = 
                      m.senderId === message.message.senderId && 
                      m.text === message.message.text;
                      
                    // Verifica pelas datas com tolerância de 2 segundos para acomodar diferenças de relógio
                    const sameTimeApprox = 
                      m.createdAt instanceof Date && message.message.createdAt instanceof Date && 
                      Math.abs(m.createdAt.getTime() - new Date(message.message.createdAt).getTime()) < 2000;
                     
                    return sameContent && sameTimeApprox;
                  });
                  
                  if (messageExists) {
                    console.log('[AdminChat] Mensagem já existe no cache, ignorando duplicação');
                    return old;
                  }
                  
                  console.log('[AdminChat] Adicionando nova mensagem ao cache local');
                  
                  // Verificar se a mensagem tem uma data válida, caso contrário criar uma
                  if (!message.message.createdAt) {
                    message.message.createdAt = new Date();
                  }
                  
                  // Adicionar a nova mensagem e garantir que o array esteja ordenado por data
                  const newMessages = [...old, message.message].sort((a, b) => {
                    const dateA = new Date(a.createdAt);
                    const dateB = new Date(b.createdAt);
                    return dateA.getTime() - dateB.getTime();
                  });
                  
                  // Como as mensagens foram alteradas, registramos que vimos esta atualização
                  console.log('[AdminChat] Lista de mensagens atualizada com sucesso, total:', newMessages.length);
                  
                  // MELHORIA: Forçar a busca de mensagens atualizadas após adicionar a nova mensagem
                  // Isso garante que todas as mensagens mais recentes sejam exibidas
                  setTimeout(() => {
                    console.log('[AdminChat] Forçando busca das mensagens mais recentes...');
                    queryClient.invalidateQueries({
                      queryKey: ['/api/admin/chat/messages', activeConversation.id, messagesLimit]
                    });
                  }, 200);
                  
                  // Notificar listas de observadores sobre a alteração
                  if (typeof window !== 'undefined') {
                    window.dispatchEvent(new CustomEvent('admin-chat:messages-updated', {
                      detail: { conversationId: activeConversation.id, count: newMessages.length }
                    }));
                  }
                  
                  // Forçar atualização da interface de forma mais eficiente
                  if (messageUpdateTimerRef.current) {
                    clearTimeout(messageUpdateTimerRef.current);
                  }
                  
                  messageUpdateTimerRef.current = setTimeout(() => {
                    console.log('[AdminChat] Atualizando estado da interface para refletir nova mensagem');
                    setLastMessageTime(new Date());
                  }, 50);
                  
                  return newMessages;
                }
              );

              // MELHORIA: Também invalidar a consulta de mensagens após um pequeno atraso
              // Isso fornece uma dupla garantia de que as mensagens serão atualizadas
              setTimeout(() => {
                queryClient.invalidateQueries({
                  queryKey: ['/api/admin/chat/messages', activeConversation.id]
                });
              }, 100);
            } else {
              // MELHORIA: Se não for a conversa ativa, mesmo assim atualizar o cache de conversas
              // para que a prévia da última mensagem seja atualizada na lista
              console.log('[AdminChat] Mensagem para conversa não-ativa, atualizando lista de conversas');
              setTimeout(() => {
                queryClient.invalidateQueries({
                  queryKey: ['/api/admin/chat/conversations']
                });
              }, 100);
            }
              
              // Reproduzir som de notificação se a mensagem não for do usuário atual
              if (message.message.senderId !== user.id) {
                console.log('[AdminChat] Mensagem de outro usuário, processando notificações');
                
                // Marcar como lida automaticamente, já que o admin está visualizando a conversa
                if (message.message.id) {
                  console.log('[AdminChat] Marcando mensagem como lida:', message.message.id);
                  apiRequest('POST', '/api/admin/chat/mark-read', { 
                    messageIds: [message.message.id] 
                  }).catch(err => console.error('[AdminChat] Erro ao marcar mensagem como lida:', err));
                }
              }
            } 
            // 3. Se não é a conversa ativa, atualizar lista de conversas e notificar
            else {
              console.log('[AdminChat] Mensagem para conversa diferente da ativa:', message.message.conversationId);
              
              // Notificação visual para mensagens de outros usuários
              if (message.message.senderId !== user.id) {
                console.log('[AdminChat] Exibindo notificação de nova mensagem de outro usuário');
                
                // Obter informações adicionais do remetente, se disponíveis
                const senderName = message.senderName || 'Usuário';
                
                toast({
                  title: 'Nova mensagem',
                  description: `De: ${senderName} - ${
                    message.message.text?.substring(0, 50) || 'Nova mensagem'
                  }${message.message.text?.length > 50 ? '...' : ''}`,
                  duration: 5000, // Duração mais longa para garantir que o usuário veja
                  variant: 'default',
                });
              }
              
              // Adicionar a mensagem ao cache de conversas para futuras referências
              const messageKey = `message_${message.message.id}_${message.message.conversationId}`;
              setMemoryCache(messageKey, message.message);
              
              // 4. Atualizar conversas com a informação da nova mensagem em tempo real
              console.log('[AdminChat] Buscando conversas atualizadas após nova mensagem');
              
              // Forçar atualização da conversa específica se for conhecida
              if (message.message.conversationId) {
                const existingConversation = conversations.find(c => c.id === message.message.conversationId);
                
                if (existingConversation) {
                  console.log('[AdminChat] Atualizando conversa específica:', existingConversation.id);
                  
                  // Criar uma versão atualizada da conversa com a nova mensagem
                  const updatedConversation = {
                    ...existingConversation,
                    lastMessageText: message.message.text || existingConversation.lastMessageText,
                    lastMessageDate: message.message.createdAt || new Date(),
                    lastActivityAt: message.message.createdAt || new Date(),
                    unreadCount: message.message.senderId !== user.id 
                      ? (existingConversation.unreadCount || 0) + 1 
                      : existingConversation.unreadCount
                  };
                  
                  // Atualizar a lista de conversas mantendo a ordem
                  setConversations(prev => {
                    // Criar cópia para modificar
                    const conversationsCopy = [...prev];
                    
                    // Encontrar e substituir a conversa antiga pela atualizada
                    const index = conversationsCopy.findIndex(c => c.id === updatedConversation.id);
                    if (index !== -1) {
                      conversationsCopy[index] = updatedConversation;
                    } else {
                      // Se não encontrarmos, adicionar à lista
                      conversationsCopy.push(updatedConversation);
                    }
                    
                    // Reordenar para que a conversa atualizada fique no topo
                    return conversationsCopy.sort((a, b) => {
                      const dateA = new Date(a.lastActivityAt || a.lastMessageDate || a.createdAt);
                      const dateB = new Date(b.lastActivityAt || b.lastMessageDate || b.createdAt);
                      return dateB.getTime() - dateA.getTime();
                    });
                  });
                  
                  // Notificar componentes sobre a alteração na lista de conversas
                  if (typeof window !== 'undefined') {
                    window.dispatchEvent(new CustomEvent('admin-chat:conversations-updated', {
                      detail: { conversationId: existingConversation.id }
                    }));
                  }
                } 
                // Se a conversa não estiver na lista atual, solicitar todas as conversas
                else {
                  console.log('[AdminChat] Conversa não encontrada na lista atual, solicitando atualização completa');
                  refreshConversations();
                }
              } else {
                // Se não tivermos o ID da conversa, solicitar todas as conversas
                console.log('[AdminChat] ID de conversa não disponível, solicitando atualização completa');
                refreshConversations();
              }
            }
            
            // 5. Verificação adicional se outros admins marcaram mensagens como lidas
            if (message.type === 'admin_read_status_update') {
              console.log('[AdminChat] Recebida atualização de status de leitura por outro administrador');
              refreshConversations();
            }
          } catch (error) {
            console.error('[AdminChat] Erro ao processar nova mensagem:', error);
            // Tentar recuperar de forma segura
            setTimeout(() => {
              refreshConversations();
            }, 2000);
          }
        }
        
        // Mensagem lida por outro usuário ou administrador
        else if (message.type === 'messages_read_by_recipient' || message.type === 'messages_read_by_admin') {
          console.log(`[AdminChat] Mensagens marcadas como lidas por ${message.type === 'messages_read_by_admin' ? 'admin' : 'destinatário'}:`, message.messageIds);
          
          try {
            if (Array.isArray(message.messageIds) && message.messageIds.length > 0) {
              // Atualizar cache local se a conversa ativa contém estas mensagens
              if (activeConversation) {
                console.log('[AdminChat] Atualizando status de leitura em mensagens da conversa ativa');
                
                queryClient.setQueryData(
                  ['/api/admin/chat/messages', activeConversation.id, messagesLimit],
                  (old: ChatMessage[] = []) => {
                    // Se não há dados, não modificar
                    if (!old || !old.length) return old;
                    
                    // Criar versão atualizada do array de mensagens
                    return old.map(msg => {
                      // Se a mensagem está na lista de lidas, marcar como lida
                      if (message.messageIds && message.messageIds.includes(msg.id)) {
                        return { ...msg, isRead: true, read: true };
                      }
                      return msg;
                    });
                  }
                );
              }
              
              // Atualizar contadores de não lidas nas conversas
              console.log('[AdminChat] Atualizando contadores de não lidas nas conversas');
              refreshConversations();
            }
          } catch (error) {
            console.error('[AdminChat] Erro ao processar status de leitura:', error);
          }
        }
        
        // Atualizações da lista de conversas enviadas pelo servidor
        else if (message.type === 'conversations_update' && Array.isArray(message.conversations)) {
          console.log(`[AdminChat] Recebida atualização de conversas via WebSocket: ${message.conversations.length} conversas`);
          
          try {
            // Verificar se temos dados válidos para evitar erros
            if (message.conversations && message.conversations.length > 0) {
              // Atualizar conversas se houver mudanças reais
              const currentIds = new Set(conversations.map(c => c.id));
              const newIds = new Set(message.conversations.map((c: any) => c.id));
              
              // Verificar se há diferenças
              let hasChanges = conversations.length !== message.conversations.length;
              if (!hasChanges) {
                for (const id of newIds) {
                  if (!currentIds.has(id)) {
                    hasChanges = true;
                    break;
                  }
                }
              }
              
              if (hasChanges) {
                console.log('[AdminChat] Detectadas alterações na lista de conversas, atualizando');
                setConversations(message.conversations);
              } else {
                console.log('[AdminChat] Lista de conversas sem alterações significativas');
              }
            }
          } catch (error) {
            console.error('[AdminChat] Erro ao processar atualização de conversas:', error);
          }
        }
        
        // Notificação de nova mensagem em conversa específica
        else if (message.type === 'new_message_received' || message.type === 'admin_chat_message') {
          console.log('[AdminChat] Recebida notificação de nova mensagem em conversa específica');
          
          try {
            // Ver se a notificação contém informações da conversa
            if (message.conversationId) {
              console.log('[AdminChat] Forçando atualização de conversa específica:', message.conversationId);
              
              // Se for a conversa ativa, atualizar mensagens
              if (activeConversation && activeConversation.id === message.conversationId) {
                console.log('[AdminChat] Atualizando mensagens da conversa ativa');
                
                // Forçar busca de mensagens atualizadas
                queryClient.invalidateQueries({
                  queryKey: ['/api/admin/chat/messages', activeConversation.id]
                });
              }
              
              // Sempre atualizar lista de conversas
              refreshConversations();
            } else {
              // Se não tivermos informações específicas, atualizar todas as conversas
              console.log('[AdminChat] Sem ID de conversa na notificação, atualizando todas as conversas');
              refreshConversations();
            }
          } catch (error) {
            console.error('[AdminChat] Erro ao processar notificação de nova mensagem:', error);
          }
        }
        
        // Outros tipos de mensagens
        else {
          // Ignorar outros tipos, mas registrar para debug
          console.log('[AdminChat] Recebida mensagem de tipo não tratado:', message.type);
        }
      }
    } catch (error) {
      console.error('[AdminChat] Erro ao processar mensagem WebSocket:', error);
    }
  }, [lastMessage, user, activeConversation, conversations, messagesLimit, toast]);
  
  /**
   * Função para calcular o número total de mensagens não lidas
   */
  const calculateUnreadCount = useCallback(() => {
    return conversations.reduce((total, conversation) => {
      return total + (conversation.unreadCount || 0);
    }, 0);
  }, [conversations]);
  
  /**
   * Efeito para buscar mensagens quando a conversa ativa muda
   */
  useEffect(() => {
    if (!activeConversation || !user || user.role !== UserRole.ADMIN) return;
    
    console.log('[AdminChat] Buscando mensagens para conversa:', activeConversation.id);
    setIsLoadingMessages(true);
    
    // Buscar mensagens mais recentes da conversa selecionada
    queryClient.fetchQuery({
      queryKey: ['/api/admin/chat/messages', activeConversation.id, messagesLimit],
      queryFn: () => apiRequest('GET', `/api/admin/chat/messages/${activeConversation.id}?limit=${messagesLimit}`)
        .then(res => res.json())
        .then(data => {
          console.log(`[AdminChat] Recebidas ${data.length} mensagens da conversa ${activeConversation.id}`);
          
          // Atualizar o estado de mensagens e marcar que a carga foi concluída
          setMessages(data);
          setHasMore(data.length >= messagesLimit);
          setIsLoadingMessages(false);
          
          // Registrar atividade para garantir sincronização frequente
          lastActivityTimestampRef.current = Date.now();
          adminChatRealTimeSync.registerAdminChatActivity(activeConversation.id);
          
          return data;
        })
    }).catch(error => {
      console.error('[AdminChat] Erro ao buscar mensagens:', error);
      setIsLoadingMessages(false);
      setMessages([]);
    });
    
    // Marcar todas as mensagens desta conversa como lidas
    if (activeConversation.unreadCount && activeConversation.unreadCount > 0) {
      console.log('[AdminChat] Marcando todas as mensagens da conversa como lidas...');
      apiRequest('POST', '/api/admin/chat/mark-conversation-read', { conversationId: activeConversation.id })
        .then(() => {
          console.log('[AdminChat] Conversa marcada como lida com sucesso');
          
          // Atualizar lista de conversas para refletir a alteração
          refreshConversations();
        })
        .catch(error => {
          console.error('[AdminChat] Erro ao marcar conversa como lida:', error);
        });
    }
  }, [activeConversation, user, messagesLimit]);
  
  /**
   * Função para carregar mais mensagens (conversa infinita para cima)
   */
  const loadMoreMessages = useCallback(() => {
    if (!activeConversation || isLoadingMessages || !hasMore) return;
    
    console.log('[AdminChat] Carregando mais mensagens...');
    
    // Incrementar limite para buscar mais mensagens
    setMessagesLimit((prev) => prev + 30);
  }, [activeConversation, isLoadingMessages, hasMore]);
  
  /**
   * Formatar data da mensagem
   */
  const formatMessageDate = useCallback((date: Date) => {
    const now = new Date();
    const messageDate = new Date(date);
    
    // Se for hoje, mostrar apenas hora
    if (messageDate.toDateString() === now.toDateString()) {
      return messageDate.toLocaleTimeString('pt-BR', {
        hour: '2-digit',
        minute: '2-digit'
      });
    }
    
    // Se for esta semana, mostrar dia da semana
    const diff = now.getTime() - messageDate.getTime();
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (days < 7) {
      return messageDate.toLocaleDateString('pt-BR', {
        weekday: 'short'
      }) + ' ' + messageDate.toLocaleTimeString('pt-BR', {
        hour: '2-digit',
        minute: '2-digit'
      });
    }
    
    // Caso contrário, mostrar data completa
    return messageDate.toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: '2-digit'
    });
  }, []);
  
  /**
   * Função para buscar todas as conversas
   */
  const refreshConversations = useCallback(() => {
    // Verificar se já estamos carregando conversas para evitar chamadas duplicadas
    if (isLoadingConversations) {
      return;
    }
    
    console.log('[AdminChat] Atualizando lista de conversas...');
    setIsLoadingConversations(true);
    
    // Buscar conversas atualizadas do servidor
    queryClient.fetchQuery({
      queryKey: ['/api/admin/chat/conversations'],
      queryFn: () => apiRequest('GET', '/api/admin/chat/conversations')
        .then(res => res.json())
        .then(data => {
          console.log(`[AdminChat] Recebidas ${data.length} conversas`);
          
          // Atualizar o estado com as conversas recebidas
          setConversations(data);
          
          // Se a conversa ativa estiver na lista, mas com dados desatualizados, atualizar
          if (activeConversation) {
            const updatedActiveConversation = data.find(c => c.id === activeConversation.id);
            if (updatedActiveConversation && JSON.stringify(updatedActiveConversation) !== JSON.stringify(activeConversation)) {
              console.log('[AdminChat] Atualizando dados da conversa ativa');
              setActiveConversation(updatedActiveConversation);
            }
          }
          
          // Notificar sobre a atualização das conversas
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new CustomEvent('admin-chat:conversations-updated'));
          }
          
          // Marcar como concluído
          setIsLoadingConversations(false);
          return data;
        })
    }).catch(error => {
      console.error('[AdminChat] Erro ao atualizar conversas:', error);
      setIsLoadingConversations(false);
      toast({
        title: 'Erro ao atualizar conversas',
        description: 'Não foi possível buscar a lista de conversas. Tente novamente mais tarde.',
        variant: 'destructive'
      });
    });
  }, [isLoadingConversations, activeConversation, toast]);
  
  /**
   * Função para enviar uma mensagem
   */
  const sendMessage = useCallback(async (text: string, attachments: string[] = []) => {
    if (!activeConversation || !text.trim()) {
      console.log('[AdminChat] Tentativa de enviar mensagem vazia ou sem conversa ativa');
      return;
    }
    
    setIsSendingMessage(true);
    console.log('[AdminChat] Enviando mensagem para conversa:', activeConversation.id);
    
    // Criar objeto da mensagem a ser enviada
    const newMessage: InsertChatMessage = {
      conversationId: activeConversation.id,
      senderId: user.id,
      receiverId: activeConversation.participantId,
      text,
      attachments,
      createdAt: new Date(),
      isAdmin: true,
      read: false,
      isRead: false
    };
    
    try {
      // Otimismo: adicionar mensagem ao cache local antes da confirmação do servidor
      const tempMessage: ChatMessage = {
        ...newMessage,
        id: Date.now(), // ID temporário
        createdAt: new Date(), // Garantir que seja uma data
      };
      
      // Adicionar ao cache de mensagens locais de forma otimista
      queryClient.setQueryData(
        ['/api/admin/chat/messages', activeConversation.id, messagesLimit],
        (old: ChatMessage[] = []) => {
          // Adicionar a nova mensagem na lista
          return [...old, tempMessage];
        }
      );
      
      // Enviar a mensagem para o servidor
      const response = await apiRequest('POST', '/api/admin/chat/messages', newMessage);
      const savedMessage = await response.json();
      
      console.log('[AdminChat] Mensagem enviada com sucesso:', savedMessage.id);
      
      // Agora atualizar o cache com a mensagem real (ID do servidor)
      queryClient.setQueryData(
        ['/api/admin/chat/messages', activeConversation.id, messagesLimit],
        (old: ChatMessage[] = []) => {
          // Substituir a mensagem temporária pela permanente
          return old.map(msg => 
            // Se tem o mesmo texto e foi enviada por nós (mensagem temporária)
            msg.text === text && msg.senderId === user.id && !msg.id.toString().includes(activeConversation.id.toString())
              ? savedMessage 
              : msg
          );
        }
      );
      
      // Notificar o servidor via WebSocket para broadcast em tempo real
      sendWebSocketMessage({
        type: 'admin_chat_message',
        message: savedMessage,
        conversationId: activeConversation.id,
        timestamp: Date.now()
      });
      
      // Atualizar lista de conversas para mostrar a mensagem mais recente
      refreshConversations();
    } catch (error) {
      console.error('[AdminChat] Erro ao enviar mensagem:', error);
      
      // Exibir erro para o usuário
      toast({
        title: 'Erro ao enviar mensagem',
        description: 'Não foi possível enviar a mensagem. Tente novamente mais tarde.',
        variant: 'destructive'
      });
      
      // Remover a mensagem temporária do cache
      queryClient.setQueryData(
        ['/api/admin/chat/messages', activeConversation.id, messagesLimit],
        (old: ChatMessage[] = []) => old.filter(msg => msg.text !== text || msg.senderId !== user.id)
      );
    } finally {
      setIsSendingMessage(false);
    }
  }, [activeConversation, user, messagesLimit, toast, sendWebSocketMessage]);
  
  /**
   * Filtrar conversas com base no modo selecionado
   */
  const filterConversations = useCallback(() => {
    if (filterMode === 'all') {
      return conversations;
    } else if (filterMode === 'clients') {
      return conversations.filter(c => c.participantRole === UserRole.CLIENT);
    } else {
      return conversations.filter(c => c.participantRole === UserRole.SUPPLIER);
    }
  }, [conversations, filterMode]);
  
  /**
   * Função para marcar todas as mensagens como lidas
   */
  const markAllAsRead = useCallback(async () => {
    console.log('[AdminChat] Marcando todas as mensagens como lidas...');
    
    try {
      await apiRequest('POST', '/api/admin/chat/mark-all-read');
      
      // Atualizar o estado local
      setConversations(prev => prev.map(c => ({
        ...c,
        unreadCount: 0
      })));
      
      toast({
        title: 'Mensagens atualizadas',
        description: 'Todas as mensagens foram marcadas como lidas',
      });
      
      // Atualizar lista de conversas para refletir mudanças
      refreshConversations();
    } catch (error) {
      console.error('[AdminChat] Erro ao marcar todas como lidas:', error);
      toast({
        title: 'Erro ao atualizar mensagens',
        description: 'Não foi possível marcar as mensagens como lidas',
        variant: 'destructive'
      });
    }
  }, [toast, refreshConversations]);
  
  /**
   * Criar uma nova conversa com um usuário
   */
  const createConversation = useCallback(async (userId: number): Promise<ChatConversation> => {
    console.log('[AdminChat] Criando nova conversa com usuário:', userId);
    
    try {
      // Verificar se já existe uma conversa com este usuário
      const existing = conversations.find(c => c.participantId === userId);
      if (existing) {
        console.log('[AdminChat] Conversa já existe, retornando existente:', existing.id);
        setActiveConversation(existing);
        return existing;
      }
      
      // Criar nova conversa
      const response = await apiRequest('POST', '/api/admin/chat/conversations', {
        participantId: userId
      });
      
      if (!response.ok) {
        throw new Error('Falha ao criar conversa');
      }
      
      const newConversation = await response.json();
      
      console.log('[AdminChat] Nova conversa criada com sucesso:', newConversation.id);
      
      // Atualizar estado e selecionar a nova conversa
      setActiveConversation(newConversation);
      refreshConversations();
      
      return newConversation;
    } catch (error) {
      console.error('[AdminChat] Erro ao criar conversa:', error);
      toast({
        title: 'Erro ao criar conversa',
        description: 'Não foi possível iniciar uma nova conversa',
        variant: 'destructive'
      });
      throw error;
    }
  }, [conversations, toast, refreshConversations]);
  
  /**
   * Função para excluir uma conversa
   */
  const deleteConversation = useCallback(async (conversationId: number) => {
    console.log('[AdminChat] Excluindo conversa:', conversationId);
    
    try {
      await apiRequest('DELETE', `/api/admin/chat/conversations/${conversationId}`);
      
      console.log('[AdminChat] Conversa excluída com sucesso:', conversationId);
      
      // Se a conversa atual for a excluída, limpar a seleção
      if (activeConversation && activeConversation.id === conversationId) {
        setActiveConversation(null);
      }
      
      // Remover a conversa da lista local
      setConversations(prev => prev.filter(c => c.id !== conversationId));
      
      toast({
        title: 'Conversa excluída',
        description: 'A conversa foi excluída com sucesso',
      });
      
      // Atualizar lista de conversas
      queryClient.invalidateQueries({
        queryKey: ['/api/admin/chat/conversations']
      });
      
      return refreshConversations();
    } catch (error) {
      console.error('[AdminChat] Erro ao excluir conversa:', error);
      
      // Se for erro 404, significa que a conversa já foi excluída ou não existe
      // Neste caso, apenas atualizamos a lista local
      if (error instanceof Error && error.message.includes('404')) {
        if (activeConversation && activeConversation.id === conversationId) {
          setActiveConversation(null);
        }
        
        setConversations(prev => prev.filter(c => c.id !== conversationId));
        
        toast({
          title: 'Conversa não encontrada',
          description: 'A conversa já foi excluída ou não existe mais',
          variant: 'destructive'
        });
        
        return refreshConversations();
      }
      
      // Outros erros são reportados normalmente
      toast({
        title: 'Erro ao excluir conversa',
        description: 'Não foi possível excluir a conversa',
        variant: 'destructive'
      });
      
      throw error;
    }
  }, [activeConversation, toast, refreshConversations]);
  
  /**
   * Limpar todos os timeouts ao desmontar o componente
   */
  const clearAllTimeouts = () => {
    // Limpar interval de polling
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current);
      pollingIntervalRef.current = null;
    }
    
    // Limpar timeout de atualização de mensagens
    if (messageUpdateTimerRef.current) {
      clearTimeout(messageUpdateTimerRef.current);
      messageUpdateTimerRef.current = null;
    }
    
    // Limpar todos os timeouts de requisição registrados
    Object.values(requestTimeoutsRef.current).forEach(timeout => {
      clearTimeout(timeout);
    });
    requestTimeoutsRef.current = {};
    
    console.log('[AdminChat] Todos os timeouts foram limpos');
  };
  
  /**
   * Limpar recursos ao desmontar
   */
  useEffect(() => {
    return () => {
      removeMessageHandler(handlerId.current);
      
      // Limpar todos os timeouts
      clearAllTimeouts();
      
      console.log('[AdminChat] Recursos limpos ao desmontar o hook');
    };
  }, []);
  
  // Calcular contagem total de mensagens não lidas
  const unreadCount = calculateUnreadCount();
  
  // Filtrar conversas com base no modo selecionado
  const filteredConversations = filterConversations();
  
  // Valor do contexto para ser disponibilizado aos componentes filhos
  const chatContextValue: AdminChatContextType = {
    activeConversation,
    setActiveConversation,
    messages,
    conversations: filteredConversations,
    unreadCount,
    usersOnline,
    sendMessage,
    loadMoreMessages,
    hasMore,
    isLoadingMessages,
    isLoadingConversations,
    isAdminChat: true,
    markAllAsRead,
    createConversation,
    filterMode,
    setFilterMode,
    formatMessageDate,
    isSendingMessage,
    refreshConversations,
    deleteConversation
  };
  
  // Renderizar o provedor de contexto com o valor calculado
  return (
    <AdminChatContext.Provider value={chatContextValue}>
      {children}
    </AdminChatContext.Provider>
  );
}

/**
 * Hook para usar o contexto de chat do administrador
 */
export function useAdminChat() {
  const context = useContext(AdminChatContext);
  
  if (!context) {
    throw new Error('useAdminChat deve ser usado dentro de um AdminChatProvider');
  }
  
  return context;
}